<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squid Game Elimination</title>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes scaleIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .animate-fadeIn {
            animation: fadeIn 0.8s ease-out;
        }
        
        .animate-scaleIn {
            animation: scaleIn 0.8s ease-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        const PhotoGrid = () => {
            const FADE_IN_DELAY = 25;
            const ELIMINATION_GROUP_DELAY = 600;
            const ELIMINATION_FLASH_DURATION = 500;
            const FADE_OUT_DURATION = 700;

            const FLASH_SCALE = 1.1;
            const FADE_SCALE = 0.9;
            const ELIMINATED_OPACITY = 0.2;
            const FLASH_BRIGHTNESS = 1.5;

            const [visiblePhotos, setVisiblePhotos] = useState(new Set());
            const [eliminated, setEliminated] = useState(new Set());
            const [flashing, setFlashing] = useState(new Set());
            const [showingX, setShowingX] = useState(new Set());
            const [allVisible, setAllVisible] = useState(false);
            const [winner, setWinner] = useState(null);
            const [audioContext, setAudioContext] = useState(null);
            const [isReady, setIsReady] = useState(false);

            // AUTO-START AUDIO ON LOAD
            useEffect(() => {
                try {
                    const context = new (window.AudioContext || window.webkitAudioContext)();
                    setAudioContext(context);

                    context.resume().then(() => {
                        setIsReady(true);
                    });
                } catch (e) {
                    console.log('Audio init error:', e);
                    setIsReady(true);
                }
            }, []);

            const playSound = (frequency, duration, type = 'sine', volume = 0.3) => {
                if (!audioContext) return;
                try {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = frequency;
                    oscillator.type = type;

                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.log('Sound error:', e);
                }
            };

            const playPopSound = () => playSound(1200, 0.08, 'sine', 0.15);
            const playEliminationSound = () => {
                playSound(80, 0.15, 'sawtooth', 0.4);
                setTimeout(() => playSound(60, 0.1, 'sawtooth', 0.3), 50);
            };
            const playWinnerSound = () => {
                setTimeout(() => playSound(523.25, 0.5, 'triangle', 0.3), 0);
                setTimeout(() => playSound(659.25, 0.5, 'triangle', 0.3), 150);
                setTimeout(() => playSound(783.99, 0.7, 'triangle', 0.3), 300);
                setTimeout(() => playSound(1046.50, 1.0, 'triangle', 0.4), 450);
            };

            const [people] = useState(() => {
                const positions = Array.from({ length: 200 }, (_, i) => i);
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                const centerPosition = 100;
                const winnerIndex = positions.indexOf(centerPosition);

                return positions.map((pos, i) => ({
                    id: i,
                    position: pos,
                    name: `Player ${pos + 1}`,
                    score: Math.floor(Math.random() * 500),
                    isWinner: i === winnerIndex
                }));
            });

            const cols = 20;

            useEffect(() => {
                if (!isReady) return;

                people.forEach((person, index) => {
                    setTimeout(() => {
                        setVisiblePhotos(prev => new Set([...prev, index]));
                        if (index % 5 === 0) playPopSound();

                        if (index === people.length - 1) {
                            setTimeout(() => setAllVisible(true), 100);
                        }
                    }, index * FADE_IN_DELAY);
                });
            }, [people, isReady]);

            useEffect(() => {
                if (!allVisible) return;

                setTimeout(() => {
                    const groupSize = 20;
                    const winnerPerson = people.find(p => p.isWinner);
                    const nonWinners = people.filter(p => !p.isWinner);
                    const numGroups = Math.ceil(nonWinners.length / groupSize);

                    for (let i = 0; i < numGroups; i++) {
                        setTimeout(() => {
                            const start = i * groupSize;
                            const end = Math.min(start + groupSize, nonWinners.length);
                            const flashingIds = [];

                            for (let j = start; j < end; j++) {
                                flashingIds.push(nonWinners[j].id);
                            }

                            setFlashing(prev => new Set([...prev, ...flashingIds]));
                            playEliminationSound();

                            setTimeout(() => {
                                setEliminated(prev => {
                                    const newSet = new Set(prev);
                                    flashingIds.forEach(id => newSet.add(id));
                                    return newSet;
                                });
                                setFlashing(prev => {
                                    const newSet = new Set(prev);
                                    flashingIds.forEach(id => newSet.delete(id));
                                    return newSet;
                                });
                            }, ELIMINATION_FLASH_DURATION);

                            if (i === numGroups - 1) {
                                setTimeout(() => {
                                    playWinnerSound();
                                    setWinner(winnerPerson);
                                }, ELIMINATION_FLASH_DURATION + 1000);
                            }
                        }, i * ELIMINATION_GROUP_DELAY);
                    }
                }, 1000);
            }, [allVisible, people]);

            return (
                <div className="w-full h-screen bg-black overflow-auto p-4 relative">
                    <div className="mb-4 text-white text-center">
                        <p className="text-lg">
                            Visible: {visiblePhotos.size} |
                            Eliminated: {eliminated.size} |
                            Remaining: {visiblePhotos.size - eliminated.size}
                        </p>
                    </div>

                    <div
                        className="grid gap-1"
                        style={{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }}
                    >
                        {Array.from({ length: 200 }).map((_, gridIndex) => {
                            const person = people.find(p => p.position === gridIndex);
                            if (!person) return <div key={gridIndex} className="aspect-square" />;

                            const isVisible = visiblePhotos.has(person.id);
                            const isEliminated = eliminated.has(person.id);
                            const isFlashing = flashing.has(person.id);
                            const isWinner = person.isWinner && winner;

                            return (
                                <div
                                    key={person.id}
                                    className="relative aspect-square"
                                    style={{
                                        opacity: !isVisible ? 0 : isEliminated ? ELIMINATED_OPACITY : isWinner ? 0 : 1,
                                        transform: !isVisible
                                            ? 'scale(0.5)'
                                            : isFlashing
                                            ? `scale(${FLASH_SCALE})`
                                            : isEliminated
                                            ? `scale(${FADE_SCALE})`
                                            : 'scale(1)',
                                        filter: isFlashing ? `brightness(${FLASH_BRIGHTNESS})` : 'none',
                                        zIndex: isFlashing ? 10 : 1,
                                        transition: isFlashing
                                            ? `all ${ELIMINATION_FLASH_DURATION}ms ease-out`
                                            : `all ${FADE_OUT_DURATION}ms ease-out`
                                    }}
                                >
                                    <div className="absolute inset-0 overflow-hidden bg-gray-900">
                                        <img
                                            src={`https://picsum.photos/200/200?random=${person.id}`}
                                            alt={person.name}
                                            className="w-full h-full object-cover"
                                        />
                                    </div>

                                    <div className="absolute bottom-0 left-0 right-0 bg-black bg-opacity-70 text-white text-xs py-1 px-2 text-center">
                                        <div className="font-bold">{person.position + 1}</div>
                                    </div>

                                    {(isEliminated || isFlashing) && (
                                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none bg-black bg-opacity-70">
                                            <div className="text-red-600 text-6xl font-bold drop-shadow-lg"
                                                 style={{ textShadow: '0 0 20px rgba(220, 38, 38, 0.8)' }}>
                                                âœ•
                                            </div>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>

                    {winner && (
                        <div className="fixed inset-0 flex items-center justify-center z-50 animate-fadeIn">
                            <div className="absolute inset-0 bg-black bg-opacity-80" />
                            <div className="relative animate-scaleIn">
                                <div
                                    className="absolute inset-0 bg-gradient-to-r from-yellow-400 via-yellow-300 to-yellow-400 rounded-lg blur-3xl opacity-75 animate-pulse"
                                    style={{ transform: 'scale(1.5)' }}
                                />

                                <div className="relative bg-gradient-to-br from-yellow-500 to-yellow-600 p-2 rounded-lg shadow-2xl">
                                    <div className="w-80 h-80 overflow-hidden rounded-lg border-4 border-yellow-300">
                                        <img
                                            src={`https://picsum.photos/400/400?random=${winner.id}`}
                                            alt={winner.name}
                                            className="w-full h-full object-cover"
                                        />
                                    </div>

                                    <div
                                        className="absolute -top-6 left-1/2 transform -translate-x-1/2 bg-gradient-to-r from-yellow-400 to-yellow-500 px-8 py-3 rounded-full shadow-xl border-4 border-yellow-300"
                                    >
                                        <div className="text-2xl font-bold text-white flex items-center gap-2">
                                            <span className="text-3xl">ðŸ‘‘</span>
                                            WINNER
                                            <span className="text-3xl">ðŸ‘‘</span>
                                        </div>
                                    </div>

                                    <div className="mt-4 text-center bg-black bg-opacity-30 rounded-lg py-3 px-4">
                                        <div className="text-3xl font-bold text-white mb-1">
                                            Player {winner.position + 1}
                                        </div>
                                        <div className="text-5xl font-bold text-yellow-300" style={{ fontFamily: 'monospace' }}>
                                            {winner.score}
                                        </div>
                                    </div>

                                    <div className="absolute top-0 left-0 text-4xl animate-bounce" style={{ animationDelay: '0s' }}>âœ¨</div>
                                    <div className="absolute top-0 right-0 text-4xl animate-bounce" style={{ animationDelay: '0.2s' }}>âœ¨</div>
                                    <div className="absolute bottom-20 left-0 text-4xl animate-bounce" style={{ animationDelay: '0.4s' }}>âœ¨</div>
                                    <div className="absolute bottom-20 right-0 text-4xl animate-bounce" style={{ animationDelay: '0.6s' }}>âœ¨</div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PhotoGrid />);
    </script>
</body>
</html>
